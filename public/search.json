[{"title":"Linux-windows双系统时间不一致","url":"/2024/04/15/Linux-windows%E5%8F%8C%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E4%B8%8D%E4%B8%80%E8%87%B4/","content":"\n问题：\n\nLinux和windows双系统安装完成后，两个系统显示时间相差八个小时。\n\n基础知识：\n\nUTC（Universal Time Coordinated）即协调世界时，以原子时长为基础，精度好。\nRTC（Real-Time Clock）实时时钟，在计算机领域称为硬件时钟，顾名思义电脑上有个硬件保存了时间信息。让我们下次启动之后，时间还可以正常显示。\n\n原因：\n\nwindows把RTC时间当作本地时间——在中国，就是东八区时间。而Linux会将RTC时间当作UTC时间。\n所以：Linux会将RTC设置成UTC时间。显示时间会根据时区显示，例如在中国，显示时间时会自动+8小时。\nLinux关机，启动windows后。Window把RTC当成了本时区的时间，直接显示。但是RTC已经被Linux设置成了UTC时间，所以显示时间会晚8个小时。\n\n解决办法：\n\n修改windows，让其将RTC硬件时间当作UTC时间。因为Linux使用RTC时间可能会导致一些程序发生错误。\n以管理员身份打开 「PowerShell」，输入以下命令：Reg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation /v RealTimeIsUniversal /tREG_DWORD /d 1\n或者打开注册表编辑器，定位到计算机\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\TimeZoneInfor\nmation 目录下，新建一个 DWORD 类型，名称为 RealTimeIsUniversal 的键，并修改键值为 1 即可。\n"},{"title":"Proxifier 2023年11月时最新版 激活教程","url":"/2024/02/16/Proxifier-2023%E5%B9%B411%E6%9C%88%E6%97%B6%E6%9C%80%E6%96%B0%E7%89%88-%E6%BF%80%E6%B4%BB%E6%95%99%E7%A8%8B/","content":"前言Proxifier 是一款功能非常强大的socks5客户端，可以让不支持通过代理服务器工作的网络程序能通过HTTPS或SOCKS代理或代理链。支持64位系统支持Xp，Vista，Win7，支持socks4，socks5，http 代理协议，支持TCPUDP协议，可以指定端口，IP，指定程序等运行模式，兼容性非常好。有许多网络应用程序不支持通过代理服务器工作，因此不能用于局域网或防火墙后面。这些会损害公司的隐私和导致很多限制。Proxifier 解决了这些问题和所有限制，让您有机会不受任何限制使用你喜爱的软件。此外它让你获得了额外的网络安全控制，创建代理隧道，并添加使用更多网络功能的权力。\n主要特点代理一切\n通过代理重定向任何互联网应用程序（浏览器、电子邮件、数据库、游戏等）的连接。\n掌握您的企业网络\n控制对资源的访问。通过单个入口点路由所有连接。从一个地方远程更新多个配置。\n改善您的联系\n通过更快的路线路由互联网流量。\n安全和隐私\n上网的轻量级和灵活的替代方案。通过加密通道隧道连接。\n超越限制\n使用代理作为您的 Internet 活动的网关。\n灵活性\n使用基于规则的系统将不同的代理或链分配给不同的连接。\n总结\n抓包比较好用\n软件官方网站地址https://www.proxifier.com/\n\n安装先去官网下载The Most Advanced Proxy Client安装版\n\n我这里使用的标准版即安装版，双击启动安装包\n\n中间弹出受否允许更改设备，请选择是，然后进入安装界面\n\n然后点击Next进入下一步\n\n选择同意协议，然后点击Next进入下一步\n\n选择安装位置后点击Next进入下一步\n\n点击Next进入下一步\n\n这里默认即可，点击Next进入下一步\n\n这里按自己的情况勾选，我这里是因为我都不需要，选项介绍：\n\n是否让Proxifier开机自启动\n检查Proxifier的更新\n在桌面创建一个Proxifier的快捷方式\n\n选择完后点击Next\n\n点击install进行安装操作\n\n点击Finish完成安装并启动Proxifier\n激活Proxifier这东西是要购买的，所以这里得给Proxifier注册一下\n\n点击Enter Registration key..进入注册界面\n\n\n上面的是注册使用的用户名\n下面的是注册使用key\n\n下面是一些key\n\nPS:尽量使用4.x系列\n\n\nstandard(标准版)\n4MHDA-C3FNN-EV6YH-ZENEQ-5A2CPYHAEF-HWLHS-CQR2A-ZENEQ-35H26987NH-LYFSC-L4V37-PWN3R-PWE7FCVYAW-WWVJD-8LA2Y-PWN3R-CZA82TET7R-EY3CC-4E43T-H0NUS-XQCS9G8E33-937CU-WM3YE-H0NUS-W236XNRNQ9-KWN42-PSU2N-CYBER-HCEB7GG2U7-5WH8W-TZF22-CYBER-BGTY3S4EMQ-NYMZF-LFT3E-ARSEN-SNZLFATV34-T2W3Y-WHNWV-ARSEN-AJJ4L5EZ8G-C3WL5-B56YG-SCXM9-6QZAP\n\nportable(便携版即免安装版)\nYYEQ8-PYURB-PVJ3E-ZENEQ-6KCYCV4FRJ-JYBNC-X4P3F-ZENEQ-G5YNEL6Z8A-XY2J4-BTZ3P-ZZ7DF-A2Q9C\n\nmacos\n87PZC-V3C3H-GTLYP-ZENEQ-2GJLTNBBCX-D242M-F97WB-ZENEQ-7VH3HP427L-9Y552-5433E-8DSR3-58Z68\n\n\n注册key的使用随便找一个，比如我这里 4MHDA-C3FNN-EV6YH-ZENEQ-5A2CP\n\n注册时有选项，问你是只为当前用户注册，还是此电脑上的所有用户，看自己选择。选择完成之后点击OK进行注册\n\nPS：点击完OK后，会弹权限认证，询问是否允许Proxifier更改设备，这个时候请选择是\n\n\n上面的图就是成功了的界面，点击确定后就可以快乐的使用Proxifier了\n原文链接：https://www.cnblogs.com/wushiyiwuzhong/p/17809020.html\n"},{"title":"Systemd 一些常用命令","url":"/2023/11/03/Systemd%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7/","content":"一、Systemd 概述Systemd 是 Linux 系统工具，用来启动守护进程，已成为大多数发行版的标准配置。根据 Linux 惯例，字母d是守护进程（daemon）的缩写。Systemd 这个名字的含义，就是它要守护整个系统。\nsystemctl --version上面的命令可以查看你的 Systemd 的版本。\nSystemd 的优点是功能强大，使用方便，缺点是体系庞大，非常复杂。事实上，现在还有很多人反对使用 Systemd，理由就是它过于复杂，与操作系统的其他部分强耦合，违反  ,   的 Unix哲学。\n\n\n二、常用命令对于那些支持 Systemd 的软件，安装的时候，会自动在/usr/lib/systemd/system目录添加一个配置文件。  \n而不支持 Systemd 的软件，如 Nginx, Alist…（以Alist为例）则需要手动编辑或创建 /usr/lib/systemd/system/alist.service并添加如下内容，其中 path_alist 为 AList 所在的路径[Unit]Description=alist                        //名称After=network.target                     //在什么之后启动 [Service]Type=simple                              //启动类型WorkingDirectory=path_alist              ExecStart=path_alist/alist server        //启动进程时执行的命令 Restart=on-failure [Install]WantedBy=multi-user.target\n然后，执行 systemctl daemon-reload 重载配置，现在你可以使用这些命令来管理程序:启动: systemctl start alist关闭: systemctl stop alist配置开机自启: systemctl enable alist取消开机自启: systemctl disable alist状态: systemctl status alist重启: systemctl restart alist  \n三、读懂配置文件配置文件主要放在 /usr/lib/systemd/system 目录，也可能在 /etc/systemd/system 目录。找到配置文件以后，使用 vim 打开即可。\n命令可以用来查看配置文件，下面以 sshd.service 文件为例，它的作用是启动一个 SSH 服务器，供其他用户以 SSH 方式登录.\n[root@jacl system]# systemctl cat sshd.service# /usr/lib/systemd/system/sshd.service[Unit]Description=OpenSSH server daemon                              //当前服务的简单描述                          Documentation=man:sshd(8) man:sshd_config(5)                   //文档位置After=network.target sshd-keygen.target                        Wants=sshd-keygen.target[Service]Type=notifyEnvironmentFile=-/etc/crypto-policies/back-ends/opensshserver.configEnvironmentFile=-/etc/sysconfig/sshdExecStart=/usr/sbin/sshd -D $OPTIONS $CRYPTO_POLICYExecReload=/bin/kill -HUP $MAINPIDKillMode=processRestart=on-failureRestartSec=42s[Install]WantedBy=multi-user.target\n可以看到，配置文件分成几个区块，每个区块包含若干条键值对。\n下面依次解释每个区块的内容。\n四、[Unit] 区块：启动顺序与依赖关系\nAfter字段：表示如果network.target或sshd-keygen.service需要启动，那么sshd.service应该在它们之后启动。\n\n相应地，还有一个Before字段，定义sshd.service应该在哪些服务之前启动。\n注意，After和Before字段只涉及启动顺序，不涉及依赖关系。\n举例来说，某 Web 应用需要 postgresql 数据库储存数据。在配置文件中，它只定义要在 postgresql 之后启动，而没有定义依赖 postgresql 。上线后，由于某种原因，postgresql 需要重新启动，在停止服务期间，该 Web 应用就会无法建立数据库连接。\n设置依赖关系，需要使用Wants字段和Requires字段。\n\nWants字段：表示sshd.service与sshd-keygen.service之间存在”弱依赖”关系，即如果sshd-keygen.service启动失败或停止运行，不影响sshd.service继续执行。\nRequires字段则表示”强依赖”关系，即如果该服务启动失败或异常退出，那么sshd.service也必须退出。\n\n五、Service] 区块：启动行为\nService区块定义如何启动当前服务。\n\n启动命令许多软件都有自己的环境参数文件，该文件可以用EnvironmentFile字段读取。\n\nEnvironmentFile字段：指定当前服务的环境参数文件。该文件内部的key=value键值对，可以用key的形式，在当前配置文件中获取。\n\n上面的例子中，sshd 的环境参数文件是/etc/sysconfig/sshd。\n配置文件里面最重要的字段是ExecStart。\n\nExecStart字段：定义启动进程时执行的命令。\n\n上面的例子中，启动sshd，执行的命令是/usr/sbin/sshd -D $OPTIONS，其中的变量$OPTIONS就来自EnvironmentFile字段指定的环境参数文件。\n与之作用相似的，还有如下这些字段。ExecReload字段：重启服务时执行的命令ExecStop字段：停止服务时执行的命令ExecStartPre字段：启动服务之前执行的命令ExecStartPost字段：启动服务之后执行的命令ExecStopPost字段：停止服务之后执行的命令\n启动类型Type字段定义启动类型。它可以设置的值如下。simple（默认值）：ExecStart字段启动的进程为主进程forking：ExecStart字段将以fork()方式启动，此时父进程将会退出，子进程将成为主进程oneshot：类似于simple，但只执行一次，Systemd 会等它执行完，才启动其他服务dbus：类似于simple，但会等待 D-Bus 信号后启动notify：类似于simple，启动结束后会发出通知信号，然后 Systemd 再启动其他服务idle：类似于simple，但是要等到其他任务都执行完，才会启动该服务。一种使用场合是为让该服务的输出，不与其他服务的输出相混合下面是一个oneshot的例子，笔记本电脑启动时，要把触摸板关掉，配置文件可以这样写。[Unit]Description=Switch-off Touchpad[Service]Type=oneshotExecStart=/usr/bin/touchpad-off[Install]WantedBy=multi-user.target上面的配置文件，启动类型设为oneshot，就表明这个服务只要运行一次就够了，不需要长期运行。\n如果关闭以后，将来某个时候还想打开，配置文件修改如下。[Unit]Description=Switch-off Touchpad[Service]Type=oneshotExecStart=/usr/bin/touchpad-off startExecStop=/usr/bin/touchpad-off stopRemainAfterExit=yes[Install]WantedBy=multi-user.target上面配置文件中，RemainAfterExit字段设为yes，表示进程退出以后，服务仍然保持执行。这样的话，一旦使用systemctl stop命令停止服务，ExecStop指定的命令就会执行，从而重新开启触摸板。\n重启行为"},{"title":"codeforces1920D.md","url":"/2024/02/03/codeforces1920D/","content":"codeforces1920D\n#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;typedef uint64_t ll;const int N=200010;const ll INF=1e18;ll lst[N];ll num[N];int n,q;void qurray(ll x){   while(true){      ll pos=upper_bound(num+1,num+n+1,x)-num;      if(pos==1){         cout&lt;&lt;lst[1]&lt;&lt;endl;      }      if(x%num[pos-1]==0){         cout&lt;&lt;lst[pos-1]&lt;&lt;\" \";         return;      }      x%=num[pos-1];   }}int main(){   int t;   cin&gt;&gt;t;   while(t--){      cin&gt;&gt;n&gt;&gt;q;      for(int i=1;i&lt;=n;i++){         ll op,x;         cin&gt;&gt;op&gt;&gt;x;         if(op==1){            num[i]=num[i-1]+1;            lst[i]=x;         }else{            ll a=x+1;            if(num[i-1]!=0){               a=min(a,INF/num[i-1]+1);            }            num[i]=num[i-1]*a;            lst[i]=lst[i-1];         }      }      while(q--){         ll x;         cin&gt;&gt;x;         qurray(x);      }      cout&lt;&lt;endl;   }    return 0;}\n","categories":["codeforces"],"tags":["codeforces"]},{"title":"Win11 Activation","url":"/2023/09/07/Win11Activation/","content":"win11专业版激活用管理员在cmd中输入下列命令:1.slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX2.slmgr /skms kms.03k.org3.slmgr /ato\n","categories":["杂项"]},{"title":"codeforces1870C","url":"/2023/09/07/codeforces1870C/","content":"codeforces1870C\n题意给你两个整数  和 。同时给你一个大小为 的整数数组 。已知对于所有 ， .\n定义大小为 的二维数组 如下：.将数组表示为一个正方形，其中左上角的单元格为，行的编号从上到下从到，列的编号从左到右从到。让一个单元格的颜色就是写在其中的数字(坐标为的单元格的颜色是) .\n对于从  到  的每种颜色，找出数组  中包含该颜色所有单元格的最小矩形。输出该矩形的宽和高之和 .\n方法 一 求最左边和最右边大于等于的数的下标, 即 。\n#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int N=100005;int le[N],ri[N];int main(){    int t;    cin&gt;&gt;t;    while(t--){        int n,k;        cin&gt;&gt;n&gt;&gt;k;        vector&lt;int&gt;a(n+1);        vector&lt;bool&gt;st(k+1);        for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i],st[a[i]]=true;        int now=0;        for(int i=1;i&lt;=n;i++){            while(now&lt;a[i]) le[++now]=i; //求最左边大于等于a[i]的数的下标        }        now=0;        for(int i=n;i&gt;=1;i--){            while(now&lt;a[i]) ri[++now]=i; //求最右边大于等于a[i]的数的下标        }        for(int i=1;i&lt;=k;i++){            cout&lt;&lt;(st[i]?(ri[i]-le[i]+1)*2:0)&lt;&lt;\" \";        }        cout&lt;&lt;endl;    }    return 0;}\n","categories":["codeforces"],"tags":["codeforces"]},{"title":"Windows与Ubuntu22.04 双系统安装","url":"/2024/04/15/Windows%E4%B8%8EUbuntu22-04-%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/","content":"一、查看基础环境1.安装环境和电脑配置\n\n\n\n配置项\n配置值\n\n\n\n\n操作系统\nWindows 11\n\n\n处理器\nAMD Ryzen 9 7945HX\n\n\n内存\n16.00GB\n\n\n硬盘\n1TB SSD\n\n\n显卡\n4060\n\n\n\n\n2.查看电脑是否支持UEFI启动win+s打开搜索，输入System Information，点击运行,如下图所示，如果BIOS Mode为UEFI，则支持UEFI启动，可进行下一步。\n\n注:\n\n部分主板不支持UEFI启动，需要使用legacy启动，具体方法可自行搜索。\n需要一个不小于8GB的U盘，用于制作启动盘。\n\n\n二、下载ubuntu22.04以及相关工具点击下载 ubuntu-22.04\n下载完成后，使用 Ventoy制作启动盘，具体使用方法可参考ventoy官网。\n制作完成后，将 ubuntu-22.04.4-desktop-amd64.iso 文件移入U盘中。\n\n三、分区及安装Ubuntu1.分区使用DiskGenius软件对U盘进行分区，具体使用方法可参考DiskGenius官网。\n给Ubuntu22.04系统分区大小100GB为宜。\n2.安装Ubuntu重新启动电脑，屏幕亮起前按 f2，进入BIOS，关闭安全启动后，退出BIOS。\n重新启动电脑，屏幕亮起前按 f12，选择你的U盘启动，选择刚下载的Ubuntu系统，进行安装，后面要注意选择安装位置为新分区就OK。\n\n四.输入法设置及时区问题1.输入法设置安装完成后，会自动进入Ubuntu系统，此时输入法无法输入中文，需要需要安装 fcitx5 .\n\n通过命令安装 fcitx5：\nsudo apt install -y fcitx5 fcitx5-chinese-addons fcitx5-frontend-gtk4sudo apt remove ibussudo apt autoremove\n\n安装完成后，需要设置输入法，通过 Settings 进入弹出的窗口中进入到如下设置界面。选择左侧Region &amp; Language，然后单击Manage Installed LanguagesSettings\n\n\n\n在弹出的窗口中，选择Keyboard input method system，下拉框中选中fcitx5\n\n单击Install/Remove Languages...在弹出的窗口中把中文加入到列表中  \n\n在命令行中输入命令fcitx5-configtool进行配置在弹出的Fcitx Configuration中把Pinyin输入法加入到左侧列表中\n\n由于输入法太多，可以在Avaliable input method:输入框中输入pinyin进行过滤，最后选中Pinyin输入法加入到左侧列表就可以了。\n\n至此整个输入法设置完毕，通过Ctrl + Space就可以在中文和英文输入法之间进行切换了\n\n2.时区设置安装完成后，由于一种神秘力量，两系统的时间会掉入时间黑洞，发生错乱，导致时间不一致，无法正常显示，此时建议在Windows下进行设置。\n"},{"title":"codeforces1954D","url":"/2024/04/26/codeforces1954D/","content":"codeforces1954D\n题意有  种颜色的球，  种颜色的球的个数是  。\n这些球可以组合成一组。每组最多包含  个球，每种颜色的球不超过  个。\n考虑所有  组颜色。对于一组颜色，让我们把它的值表示为这些颜色的球所能分配到的最少组数。例如，如果有三种颜色，分别有  、  和  个球，它们可以组合成  组（且不少于  ），那么这组颜色的值就是  。\n你的任务是计算所有  可能的颜色组的值之和。由于答案可能太大，请打印出以  为模数的答案。\n输入第一行包含一个整数  (  ) - 颜色的数量。\n第二行包含  个整数  (  ) -  -th 颜色的球数。\n输入的额外限制：球的总数不超过  。\n输出打印一个整数 —— 所有  组颜色的值之和，取模为  。\n分析对于一个固定的颜色集合，这是一个标准问题，其解法如下：假设球的总数为  ，则集合的值为  ；但有一种例外情况，即有一种颜色的球数多于  ，那么值就是这种颜色的球数。\n因此，答案只取决于是否有一种颜色的球数比其他颜色的球数总和还要多。\n所以我们可以给各种颜色小球的数量排个序,然后枚举数量最多的小球有多少个,用背包统计之前选了  个小球的方案数,然后就可以得到答案了。（因为是所有组合   种，想到背包模型是关键）\n  : 选了  个小球的方案数\nCode#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const long long N=3e5+10;long long dp[N];long long a[N];long long mod = 998244353;int main(){    long long n;    cin&gt;&gt;n;    for(long long i=1;i&lt;=n;i++) cin&gt;&gt;a[i];        sort(a+1,a+1+n);    long long ans=0;    dp[0]=1;    for(long long i=1;i&lt;=n;i++){        for(long long j=0;j&lt;=5000-a[i];j++){            if(a[i]&gt;j) ans=(ans+dp[j]*a[i])%mod;            else ans=(ans+dp[j]*((j+a[i]+1)/2))%mod;        }        for(long long j=5000-a[i];j&gt;=0;j--){            dp[j+a[i]]=(dp[j+a[i]]+dp[j])%mod;        }    }    cout&lt;&lt;ans%mod&lt;&lt;endl;    return 0;}\n","categories":["codeforces"],"tags":["codeforces"]},{"title":"redis","url":"/2024/02/02/redis/","content":"","tags":["工具"]},{"title":"codeforces882D","url":"/2023/09/07/codeforces882D/","content":"codeforces1870C连续  个数字里边必有能整除  的数字 , 所以只需从  开始枚举 .\n#include&lt;iostream&gt;using namespace std;int main(){    int t;    cin&gt;&gt;t;    while(t--){        long long int n;        cin&gt;&gt;n;        int ans=0;        for(int i=1;i&lt;=n;i++){            if(n%i==0) ans++;            else break;        }        cout&lt;&lt;ans&lt;&lt;endl;    }    return 0;}\n","categories":["codeforces"],"tags":["codeforces"]},{"title":"实习","url":"/2024/04/15/%E5%AE%9E%E4%B9%A0/","content":"实习云南联合视觉科技有限公司录用通知（职位：后端工程师，部门：产品技术部）\n","categories":["杂项"],"tags":["实习"]},{"title":"hexo的常用命令","url":"/2023/10/28/hexo%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","content":"安装、升级npm install hexo -g #安装  npm update hexo -g #升级  \n基本命令hexo init初始化站点，生成一个简单网站所需的各种文件。\nhexo clean == hexo c清除缓存 网页正常情况下可以忽略此条命令\nhexo generate == hexo g生效新增、修改、更新的文件\nHexo 能够监视文件变动并立即重新生成静态文件，在生成时会比对文件的 SHA1 checksum，只有变动的文件才会写入。hexo generate --watch\nhexo server == hexo s启动本地网站，可在本地观察网站效果，同时也可以输入http://localhost:4000/admin管理文章\nhexo s --draft这个发布时可以预览草稿\nhexo s --debug以调试模式启动本地网站，在此模式下，对文件的更改无需停止网站只需刷新即可看到效果，调试非常方便\nhexo clean &amp;&amp; hexo s一次执行两个命令\nhexo deploy == hexo dhexo的一键部署功能，执行此命令即可将网站发布到配置中的仓库地址，执行此命令前需要配置站点配置文件_config.yml\n一键本地启动：hexo clean &amp;&amp; hexo g &amp;&amp; hexo s\n一键部署：hexo clean &amp;&amp; hexo g &amp;&amp; hexo d\n您可执行下列的其中一个命令，让 Hexo 在生成完毕后自动部署网站，两个命令的作用是相同的。hexo generate --deployhexo deploy --generate  或 hexo g -d or hexo d -g\n创建和发布文章hexo new [layout] &lt;title&gt;新建一篇新文章，会自动按照模板里面的格式创建文章\n里面的布局（layout），默认为 post，布局共有三种：post\tsource/_postspage\tsourcedraft\tsource/_drafts\n发布草稿命令：hexo publish 文章文件名或者是手动将_drafts目录下的草稿移动到_posts目录下即可发布草稿为正式文章。\nPicGO图床快捷键快捷键为：ctrl+shift+p\nHexo博客头部配置（1）文章置顶在文章的 Front-Matter 中，使用 top: true 来实现置顶。\n（2）自定义样式如果你想修改主题的样式，推荐将样式代码添加到 source/css/_custom 目录下的 index.styl 文件中。这样，当主题更新时，不会覆盖你已经修改了的样式代码。\n\n当然，你也可以进行模块化分类：在该目录下新建样式文件，然后通过 @import xxx 语句在同目录下的 index.styl 文件中引入你新建的样式文件。\n\n（3）文章左侧目录启用文章目录后，默认对所有文章页面生效。你可以在 Front-Matter 中，设置 toc: false 来指定某篇文章不启用该功能。\n（4）文章业内目录@[TOC]( )这个写到文章页面内任何一个地方即可\n更多详细设置，请参考 hexo-theme-stun"},{"title":"树状数组维护区间最值","url":"/2024/05/10/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BB%B4%E6%8A%A4%E5%8C%BA%E9%97%B4%E6%9C%80%E5%80%BC/","content":"树状数组维护区间最值一, 工作原理\n树状数组是一种支持单点修改和区间查询的数据结构。普通树状数组维护的信息及运算要满足结合律且可差分，如加法（和）、乘法（积）、异或等。 ——OI WIKI\n\n\n数组中下标为x的元素管辖区间为[x-lowbit(x)+1,x]\n二，建树void build(){    for (int i = 1; i &lt;= n; i++)    {        tree[i] = max(tree[i], a[i]);        int j = i + lowbit(i);        if (j &lt;= n) tree[j] = max(tree[j], tree[i]);    }}\n三，单点修改\nvoid add(int x, int c){    tree[x] = a[x] = c;    for (int i = 1; i &lt; lowbit(x); i &lt;&lt;= 1) tree[x] = max(tree[x], tree[x - i]);    for (int i = x; i + lowbit(i) &lt;= n; i += lowbit(i))    {        int j = lowbit(i);        tree[i + j] = max(tree[i + j], tree[i]);    }}\n四，区间查询int query(int l, int r){    int res = -INF;    while (l &lt;= r)    {        for (; l &lt;= r &amp;&amp; r - lowbit(r) + 1 &gt;= l; r -= lowbit(r))        {            res = max(tree[r], res);        }        if (l &gt; r) break;        res = max(a[r], res);        r--;    }    return res;}","categories":["codeforces"],"tags":["codeforces"]},{"title":"背包问题","url":"/2024/05/11/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","content":"背包问题引入简介：背包问题是一个经典的 组合优化问题，用于描述在给定的背包容量下如何选择物品以使得其价值最大化。通常情况下，背包问题可以分为 0-1 背包问题 和 分数背包问题 两种，其他还有 完全背包问题，分组背包问题。\n解决方法：常见的解决方法有动态规划、贪心算法和回溯算法等。其中，动态规划是解决这类问题的主流方法之一，其时间复杂度相对较低。\n0-1 背包_例题：_\n\n题意概要：有 n 种物品和一个容量为 _W_ 的背包，每种物品有重量  和价值  两种属性并且每种物品只有一个，要求选若干个物品放入背包使背包中物品的总价值最大且背包中物品的总重量不超过背包的容量。\n\n_Code:_\nconst int N=1e5+10;int n,W,w[N],v[N];long long dp[100*N];void solve(){    cin&gt;&gt;W&gt;&gt;n;    for(int i=1;i&lt;=n;i++) cin&gt;&gt;w[i]&gt;&gt;v[i];    for(int i=1;i&lt;=n;i++){        for(int j=W;j&gt;=w[i];j--){            dp[j]=max(dp[j],dp[j-w[i]]+v[i]);        }    }    cout&lt;&lt;dp[W]&lt;&lt;endl;}\n分析：\n建立状态表示 dp[i][j]: 从前 i 个物品选择放入容量为 j 的背包中的最大价值。\n二维动态规划状态转移方程：\n一维动态规划状态转移方程：\n"}]