[{"title":"实习","url":"/2025/04/15/实习/","content":"# 实习\n## 云南联合视觉科技有限公司录用通知（职位：后端工程师，部门：产品技术部）  \n![云南联合视觉科技有限公司录用通知](./实习/image_01.png)","tags":["实习"]},{"title":"背包问题","url":"/2024/05/11/背包问题/","content":"\n# 背包问题\n\n## 引入\n\n简介：背包问题是一个经典的 **组合优化问题**，用于描述在给定的背包容量下如何选择物品以使得其价值最大化。通常情况下，背包问题可以分为 **0-1 背包问题** 和 **分数背包问题** 两种，其他还有 **完全背包问题**，**分组背包问题**。\n\n解决方法：常见的解决方法有动态规划、贪心算法和回溯算法等。其中，动态规划是解决这类问题的主流方法之一，其时间复杂度相对较低。\n\n## 0-1 背包\n\n**_例题：_**\n\n> 题意概要：有 n 种物品和一个容量为 **_W_** 的背包，每种物品有重量 $w_i$ 和价值 $v_{i}$ 两种属性并且每种物品只有一个，要求选若干个物品放入背包使背包中物品的总价值最大且背包中物品的总重量不超过背包的容量。\n\n**_Code:_**\n\n```c++\nconst int N=1e5+10;\nint n,W,w[N],v[N];\nlong long dp[100*N];\nvoid solve()\n{\n    cin>>W>>n;\n    for(int i=1;i<=n;i++) cin>>w[i]>>v[i];\n    for(int i=1;i<=n;i++){\n        for(int j=W;j>=w[i];j--){\n            dp[j]=max(dp[j],dp[j-w[i]]+v[i]);\n        }\n    }\n    cout<<dp[W]<<endl;\n}\n```\n***分析：***\n\n建立状态表示 ```dp[i][j]```: 从前 ```i``` 个物品选择放入容量为 ```j``` 的背包中的最大价值。\n\n二维动态规划状态转移方程：$dp[i][j] = max(dp[i-1][j], dp[i-1][j-v[i]] + w[i])$\n\n一维动态规划状态转移方程：$dp[j] = max(dp[j], dp[j - v[i]] + w[i])$\n\n"},{"title":"树状数组维护区间最值","url":"/2024/05/10/树状数组维护区间最值/","content":"# 树状数组维护区间最值\n\n## 一, 工作原理\n\n> 树状数组是一种支持**单点修改**和**区间查询**的数据结构。普通树状数组维护的信息及运算要满足**结合律**且**可差分**，如加法（和）、乘法（积）、异或等。 ——OI WIKI\n\n![img](树状数组维护区间最值\\01.svg)\n\n数组中下标为x的元素管辖区间为```[x-lowbit(x)+1,x]```\n\n## 二，建树\n\n```c++\nvoid build()\n{\n    for (int i = 1; i <= n; i++)\n    {\n        tree[i] = max(tree[i], a[i]);\n        int j = i + lowbit(i);\n        if (j <= n) tree[j] = max(tree[j], tree[i]);\n    }\n}\n```\n\n## 三，单点修改\n\n![img](树状数组维护区间最值\\02.png)\n\n```c++\nvoid add(int x, int c)\n{\n    tree[x] = a[x] = c;\n    for (int i = 1; i < lowbit(x); i <<= 1) tree[x] = max(tree[x], tree[x - i]);\n\n    for (int i = x; i + lowbit(i) <= n; i += lowbit(i))\n    {\n        int j = lowbit(i);\n        tree[i + j] = max(tree[i + j], tree[i]);\n    }\n}\n```\n\n## 四，区间查询\n\n```c++\nint query(int l, int r)\n{\n    int res = -INF;\n    while (l <= r)\n    {\n        for (; l <= r && r - lowbit(r) + 1 >= l; r -= lowbit(r))\n        {\n            res = max(tree[r], res);\n        }\n\n        if (l > r) break;\n        res = max(a[r], res);\n        r--;\n    }\n    return res;\n}\n```","tags":["codeforces"],"categories":["codeforces"]},{"title":"codeforces1954D","url":"/2024/04/26/codeforces1954D/","content":"[codeforces1954D](https://codeforces.com/contest/1954/problem/D)\n\n## 题意\n有 $n$ 种颜色的球， $i$ 种颜色的球的个数是 $a_i$ 。\n\n这些球可以组合成一组。每组最多包含 $2$ 个球，每种颜色的球不超过 $1$ 个。\n\n考虑所有 $2^n$ 组颜色。对于一组颜色，让我们把它的值表示为这些颜色的球所能分配到的最少组数。例如，如果有三种颜色，分别有 $3$ 、 $1$ 和 $7$ 个球，它们可以组合成 $7$ 组（且不少于 $7$ ），那么这组颜色的值就是 $7$ 。\n\n你的任务是计算所有 $2^n$ 可能的颜色组的值之和。由于答案可能太大，请打印出以 $998\\,244\\,353$ 为模数的答案。\n\n#### 输入\n\n第一行包含一个整数 $n$ ( $1 \\le n \\le 5000$ ) - 颜色的数量。\n\n第二行包含 $n$ 个整数 $a_1, a_2, \\dots, a_n$ ( $1 \\le a_i \\le 5000$ ) - $i$ -th 颜色的球数。\n\n输入的额外限制：球的总数不超过 $5000$ 。\n\n#### 输出\n\n打印一个整数 —— 所有 $2^n$ 组颜色的值之和，取模为 $998\\,244\\,353$ 。\n\n## 分析\n对于一个固定的颜色集合，这是一个标准问题，其解法如下：假设球的总数为 $s$ ，则集合的值为 $\\left\\lceil\\frac{s}{2}\\right\\rceil$ ；但有一种例外情况，即有一种颜色的球数多于 $\\frac{s}{2}$ ，那么值就是这种颜色的球数。\n\n因此，答案只取决于是否有一种颜色的球数比其他颜色的球数总和还要多。\n\n所以我们可以给各种颜色小球的数量排个序,然后枚举数量最多的小球有多少个,用背包统计之前选了 $x$ 个小球的方案数,然后就可以得到答案了。（因为是所有组合  $2^n$ 种，想到背包模型是关键）\n\n $dp[i]$ : 选了 $i$ 个小球的方案数\n\n\n## Code\n```c++\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst long long N=3e5+10;\n\nlong long dp[N];\nlong long a[N];\nlong long mod = 998244353;\nint main()\n{\n    long long n;\n    cin>>n;\n    for(long long i=1;i<=n;i++) cin>>a[i];\n    \n    sort(a+1,a+1+n);\n    long long ans=0;\n    dp[0]=1;\n    for(long long i=1;i<=n;i++){\n        for(long long j=0;j<=5000-a[i];j++){\n            if(a[i]>j) ans=(ans+dp[j]*a[i])%mod;\n            else ans=(ans+dp[j]*((j+a[i]+1)/2))%mod;\n        }\n        for(long long j=5000-a[i];j>=0;j--){\n            dp[j+a[i]]=(dp[j+a[i]]+dp[j])%mod;\n        }\n    }\n    cout<<ans%mod<<endl;\n    return 0;\n}\n```\n\n\n\n\n\n\n","tags":["codeforces"],"categories":["codeforces"]},{"title":"Linux-windows双系统时间不一致","url":"/2024/04/15/Linux-windows双系统时间不一致/","content":"* 问题：\n\nLinux和windows双系统安装完成后，两个系统显示时间相差八个小时。\n\n* 基础知识：\n\nUTC（Universal Time Coordinated）即协调世界时，以原子时长为基础，精度好。\n\nRTC（Real-Time Clock）实时时钟，在计算机领域称为硬件时钟，顾名思义电脑上有个硬件保存了时间信息。让我们下次启动之后，时间还可以正常显示。\n\n* 原因：\n\nwindows把RTC时间当作本地时间——在中国，就是东八区时间。而Linux会将RTC时间当作UTC时间。\n\n所以：Linux会将RTC设置成UTC时间。显示时间会根据时区显示，例如在中国，显示时间时会自动+8小时。\n\nLinux关机，启动windows后。Window把RTC当成了本时区的时间，直接显示。但是RTC已经被Linux设置成了UTC时间，所以显示时间会晚8个小时。\n\n* 解决办法：\n\n修改windows，让其将RTC硬件时间当作UTC时间。因为Linux使用RTC时间可能会导致一些程序发生错误。\n\n以管理员身份打开 「PowerShell」，输入以下命令：\n```Reg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation /v RealTimeIsUniversal /tREG_DWORD /d 1```\n\n\n或者打开```注册表编辑器```，定位到计算机```\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\TimeZoneInfor\nmation``` 目录下，新建一个 ```DWORD``` 类型，名称为 ```RealTimeIsUniversal``` 的键，并修改键值为 ```1``` 即可。\n"},{"title":"Windows与Ubuntu22.04 双系统安装","url":"/2024/04/15/Windows与Ubuntu22-04-双系统安装/","content":"\n### 一、查看基础环境\n\n#### 1.安装环境和电脑配置\n\n| 配置项 | 配置值 |\n| -------- | -------- |\n| 操作系统 | Windows 11 |\n| 处理器 | AMD Ryzen 9 7945HX |\n| 内存 | 16.00GB |\n| 硬盘 | 1TB SSD |\n| 显卡 |  4060 |\n\n#### 2.查看电脑是否支持UEFI启动\nwin+s打开搜索，输入System Information，点击运行,如下图所示，如果BIOS Mode为UEFI，则支持UEFI启动，可进行下一步。\n\n![image_01](./Windows与Ubuntu22-04-双系统安装/image_01.png)\n\n注:\n- 部分主板不支持UEFI启动，需要使用legacy启动，具体方法可自行搜索。\n- 需要一个不小于8GB的U盘，用于制作启动盘。\n\n---\n\n### 二、下载ubuntu22.04以及相关工具\n\n点击下载 [ubuntu-22.04](https://mirrors.bfsu.edu.cn/ubuntu-releases/jammy/ubuntu-22.04.4-desktop-amd64.iso)\n\n下载完成后，使用 [Ventoy](https://www.ventoy.net/cn/index.html)制作启动盘，具体使用方法可参考ventoy官网。\n\n制作完成后，将 **ubuntu-22.04.4-desktop-amd64.iso** 文件移入U盘中。\n\n---\n\n### 三、分区及安装Ubuntu\n\n#### 1.分区\n\n使用[DiskGenius](https://www.diskgenius.com/)软件对U盘进行分区，具体使用方法可参考DiskGenius官网。\n\n给Ubuntu22.04系统分区大小100GB为宜。\n\n#### 2.安装Ubuntu\n\n重新启动电脑，屏幕亮起前按 f2，进入BIOS，关闭安全启动后，退出BIOS。\n\n重新启动电脑，屏幕亮起前按 f12，选择你的U盘启动，选择刚下载的Ubuntu系统，进行安装，后面要注意选择安装位置为新分区就OK。\n\n---\n\n### 四.输入法设置及时区问题\n\n#### 1.输入法设置\n\n安装完成后，会自动进入Ubuntu系统，此时输入法无法输入中文，需要需要安装 fcitx5 .\n\n* 通过命令安装 fcitx5：\n```shell\nsudo apt install -y fcitx5 fcitx5-chinese-addons fcitx5-frontend-gtk4\nsudo apt remove ibus\nsudo apt autoremove\n```\n\n* 安装完成后，需要设置输入法，通过 ```Settings``` 进入弹出的窗口中进入到如下设置界面。  \n选择左侧```Region & Language```，然后单击```Manage Installed LanguagesSettings```\n\n![image_02](./Windows与Ubuntu22-04-双系统安装/image_02.png)\n\n在弹出的窗口中，选择```Keyboard input method system```，下拉框中选中```fcitx5```\n\n![image_03](./Windows与Ubuntu22-04-双系统安装/image_03.png)\n\n单击```Install/Remove Languages...```在弹出的窗口中把中文加入到列表中  \n\n* 在命令行中输入命令```fcitx5-configtool```进行配置在弹出的```Fcitx Configuration```中把```Pinyin```输入法加入到左侧列表中\n\n![image_04](./Windows与Ubuntu22-04-双系统安装/image_04.png)\n由于输入法太多，可以在```Avaliable input method:```输入框中输入```pinyin```进行过滤，最后选中```Pinyin```输入法加入到左侧列表就可以了。\n\n> 至此整个输入法设置完毕，通过```Ctrl + Space```就可以在中文和英文输入法之间进行切换了\n\n#### 2.时区设置\n\n安装完成后，由于一种神秘力量，两系统的时间会掉入[时间黑洞](../Linux-windows双系统时间不一致)，发生错乱，导致时间不一致，无法正常显示，此时建议在```Windows```下进行设置。\n"},{"title":"Proxifier 2023年11月时最新版 激活教程","url":"/2024/02/16/Proxifier-2023年11月时最新版-激活教程/","content":"## 前言\nProxifier 是一款功能非常强大的socks5客户端，可以让不支持通过代理服务器工作的网络程序能通过HTTPS或SOCKS代理或代理链。支持64位系统支持Xp，Vista，Win7，支持socks4，socks5，http 代理协议，支持TCPUDP协议，可以指定端口，IP，指定程序等运行模式，兼容性非常好。有许多网络应用程序不支持通过代理服务器工作，因此不能用于局域网或防火墙后面。这些会损害公司的隐私和导致很多限制。Proxifier 解决了这些问题和所有限制，让您有机会不受任何限制使用你喜爱的软件。此外它让你获得了额外的网络安全控制，创建代理隧道，并添加使用更多网络功能的权力。\n\n## 主要特点\n代理一切\n\n通过代理重定向任何互联网应用程序（浏览器、电子邮件、数据库、游戏等）的连接。\n\n掌握您的企业网络\n\n控制对资源的访问。通过单个入口点路由所有连接。从一个地方远程更新多个配置。\n\n改善您的联系\n\n通过更快的路线路由互联网流量。\n\n安全和隐私\n\n上网的轻量级和灵活的替代方案。通过加密通道隧道连接。\n\n超越限制\n\n使用代理作为您的 Internet 活动的网关。\n\n灵活性\n\n使用基于规则的系统将不同的代理或链分配给不同的连接。\n\n总结\n\n**抓包比较好用**\n\n软件官方网站地址  \nhttps://www.proxifier.com/\n\n![图片](./Proxifier-2023年11月时最新版-激活教程/01.png)\n\n\n## 安装\n先去官网下载[The Most Advanced Proxy Client](https://www.proxifier.com/)安装版\n\n![图片](./Proxifier-2023年11月时最新版-激活教程/02.png)\n\n我这里使用的标准版即安装版，双击启动安装包\n\n![图片](./Proxifier-2023年11月时最新版-激活教程/03.png)\n\n中间弹出受否允许更改设备，请选择是，然后进入安装界面\n\n![图片](./Proxifier-2023年11月时最新版-激活教程/04.png)\n\n然后点击Next进入下一步\n\n![图片](./Proxifier-2023年11月时最新版-激活教程/05.png)\n\n选择同意协议，然后点击Next进入下一步\n\n![图片](./Proxifier-2023年11月时最新版-激活教程/06.png)\n\n选择安装位置后点击Next进入下一步\n\n![图片](./Proxifier-2023年11月时最新版-激活教程/07.png)\n\n点击Next进入下一步\n\n![图片](./Proxifier-2023年11月时最新版-激活教程/08.png)\n\n这里默认即可，点击Next进入下一步\n\n![图片](./Proxifier-2023年11月时最新版-激活教程/09.png)\n\n这里按自己的情况勾选，我这里是因为我都不需要，选项介绍：\n\n- 是否让Proxifier开机自启动\n- 检查Proxifier的更新\n- 在桌面创建一个Proxifier的快捷方式\n\n选择完后点击Next\n\n![图片](./Proxifier-2023年11月时最新版-激活教程/10.png)\n\n点击install进行安装操作\n\n![图片](./Proxifier-2023年11月时最新版-激活教程/11.png)\n\n点击Finish完成安装并启动Proxifier\n\n## 激活Proxifier\n这东西是要购买的，所以这里得给Proxifier注册一下\n\n![图片](./Proxifier-2023年11月时最新版-激活教程/12.png)\n\n点击Enter Registration key..进入注册界面\n\n![图片](./Proxifier-2023年11月时最新版-激活教程/13.png)\n\n- 上面的是注册使用的用户名\n- 下面的是注册使用key\n\n下面是一些key\n\n>PS:尽量使用4.x系列\n\n- standard(标准版)\n```\n4MHDA-C3FNN-EV6YH-ZENEQ-5A2CP\nYHAEF-HWLHS-CQR2A-ZENEQ-35H26\n987NH-LYFSC-L4V37-PWN3R-PWE7F\nCVYAW-WWVJD-8LA2Y-PWN3R-CZA82\nTET7R-EY3CC-4E43T-H0NUS-XQCS9\nG8E33-937CU-WM3YE-H0NUS-W236X\nNRNQ9-KWN42-PSU2N-CYBER-HCEB7\nGG2U7-5WH8W-TZF22-CYBER-BGTY3\nS4EMQ-NYMZF-LFT3E-ARSEN-SNZLF\nATV34-T2W3Y-WHNWV-ARSEN-AJJ4L\n5EZ8G-C3WL5-B56YG-SCXM9-6QZAP\n```\n\n- portable(便携版即免安装版)\n```\nYYEQ8-PYURB-PVJ3E-ZENEQ-6KCYC\nV4FRJ-JYBNC-X4P3F-ZENEQ-G5YNE\nL6Z8A-XY2J4-BTZ3P-ZZ7DF-A2Q9C\n```\n\n- macos\n```\n87PZC-V3C3H-GTLYP-ZENEQ-2GJLT\nNBBCX-D242M-F97WB-ZENEQ-7VH3H\nP427L-9Y552-5433E-8DSR3-58Z68\n```\n\n### 注册key的使用\n随便找一个，比如我这里 `4MHDA-C3FNN-EV6YH-ZENEQ-5A2CP`\n\n![图片](./Proxifier-2023年11月时最新版-激活教程/14.png)\n\n注册时有选项，问你是只为当前用户注册，还是此电脑上的所有用户，看自己选择。选择完成之后点击OK进行注册\n\n> PS：点击完OK后，会弹权限认证，询问是否允许Proxifier更改设备，这个时候请选择是\n> \n> ![图片](./Proxifier-2023年11月时最新版-激活教程/15.png)\n\n上面的图就是成功了的界面，点击确定后就可以快乐的使用Proxifier了\n\n原文链接：https://www.cnblogs.com/wushiyiwuzhong/p/17809020.html"},{"title":"codeforces1920D.md","url":"/2024/02/03/codeforces1920D/","content":"[codeforces1920D](https://codeforces.com/contest/1920/problem/D)\n\n```c++\n#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef uint64_t ll;\nconst int N=200010;\nconst ll INF=1e18;\nll lst[N];\nll num[N];\nint n,q;\n\nvoid qurray(ll x){\n   while(true){\n      ll pos=upper_bound(num+1,num+n+1,x)-num;\n      if(pos==1){\n         cout<<lst[1]<<endl;\n      }\n      if(x%num[pos-1]==0){\n         cout<<lst[pos-1]<<\" \";\n         return;\n      }\n      x%=num[pos-1];\n   }\n}\n\nint main()\n{\n   int t;\n   cin>>t;\n   while(t--){\n      cin>>n>>q;\n      for(int i=1;i<=n;i++){\n         ll op,x;\n         cin>>op>>x;\n         if(op==1){\n            num[i]=num[i-1]+1;\n            lst[i]=x;\n         }else{\n            ll a=x+1;\n            if(num[i-1]!=0){\n               a=min(a,INF/num[i-1]+1);\n            }\n            num[i]=num[i-1]*a;\n            lst[i]=lst[i-1];\n         }\n      }\n      while(q--){\n         ll x;\n         cin>>x;\n         qurray(x);\n      }\n      cout<<endl;\n   } \n   return 0;\n}\n```\n","tags":["codeforces"],"categories":["codeforces"]},{"title":"redis","url":"/2024/02/02/redis/","tags":["工具"]},{"title":"Systemd 一些常用命令","url":"/2023/11/03/Systemd一些技巧/","content":"## 一、Systemd 概述\n__Systemd__ 是 Linux 系统工具，用来启动[守护进程](https://www.ruanyifeng.com/blog/2016/02/linux-daemon.html)，已成为大多数发行版的标准配置。根据 Linux 惯例，字母d是守护进程（daemon）的缩写。Systemd 这个名字的含义，就是它要守护整个系统。\n\n```systemctl --version```  \n上面的命令可以查看你的 Systemd 的版本。\n\n__Systemd__ 的优点是功能强大，使用方便，缺点是体系庞大，非常复杂。事实上，现在还有很多人反对使用 Systemd，理由就是它过于复杂，与操作系统的其他部分强耦合，违反 $keep$ $simple$, $keep$ $stupid$ 的 [Unix](https://www.ruanyifeng.com/blog/2009/06/unix_philosophy.html)哲学。\n\n<!-- ![Alt text](image.png) -->\n<!-- （上图为 Systemd 架构图） -->\n\n## 二、常用命令\n对于那些支持 ```Systemd``` 的软件，安装的时候，会自动在```/usr/lib/systemd/system```目录添加一个配置文件。  \n\n而不支持 Systemd 的软件，如 ```Nginx```, ```Alist```...（以```Alist```为例）则需要手动编辑或创建 ```/usr/lib/systemd/system/alist.service```并添加如下内容，其中 ```path_alist``` 为 ```AList``` 所在的路径\n```shell\n[Unit]\nDescription=alist                        //名称\nAfter=network.target                     //在什么之后启动\n \n[Service]\nType=simple                              //启动类型\nWorkingDirectory=path_alist              \nExecStart=path_alist/alist server        //启动进程时执行的命令 \nRestart=on-failure\n \n[Install]\nWantedBy=multi-user.target\n```\n\n\n然后，执行 ```systemctl daemon-reload``` 重载配置，现在你可以使用这些命令来管理程序:  \n启动: ```systemctl start alist```  \n关闭: ```systemctl stop alist```  \n配置开机自启: ```systemctl enable alist```  \n取消开机自启: ```systemctl disable alist```  \n状态: ```systemctl status alist```  \n重启: ```systemctl restart alist```  \n\n\n## 三、读懂配置文件\n配置文件主要放在 ```/usr/lib/systemd/system``` 目录，也可能在 ```/etc/systemd/system``` 目录。找到配置文件以后，使用 ```vim``` 打开即可。\n\n命令可以用来查看配置文件，下面以 ```sshd.service``` 文件为例，它的作用是启动一个 ```SSH``` 服务器，供其他用户以 ```SSH``` 方式登录.\n\n```shell\n[root@jacl system]# systemctl cat sshd.service\n# /usr/lib/systemd/system/sshd.service\n\n[Unit]\nDescription=OpenSSH server daemon                              //当前服务的简单描述                          \nDocumentation=man:sshd(8) man:sshd_config(5)                   //文档位置\nAfter=network.target sshd-keygen.target                        \nWants=sshd-keygen.target\n\n[Service]\nType=notify\nEnvironmentFile=-/etc/crypto-policies/back-ends/opensshserver.config\nEnvironmentFile=-/etc/sysconfig/sshd\nExecStart=/usr/sbin/sshd -D $OPTIONS $CRYPTO_POLICY\nExecReload=/bin/kill -HUP $MAINPID\nKillMode=process\nRestart=on-failure\nRestartSec=42s\n\n[Install]\nWantedBy=multi-user.target\n```\n可以看到，配置文件分成几个区块，每个区块包含若干条键值对。\n\n下面依次解释每个区块的内容。\n\n## 四、[Unit] 区块：启动顺序与依赖关系\n> **After**字段：表示如果```network.target```或```sshd-keygen.service```需要启动，那么```sshd.service```应该在它们之后启动。\n\n相应地，还有一个```Before```字段，定义```sshd.service```应该在哪些服务之前启动。\n\n注意，```After```和```Before```字段只涉及启动顺序，不涉及依赖关系。\n\n举例来说，某 **Web** 应用需要 **postgresql** 数据库储存数据。在配置文件中，它只定义要在 **postgresql** 之后启动，而没有定义依赖 **postgresql** 。上线后，由于某种原因，**postgresql** 需要重新启动，在停止服务期间，该 **Web** 应用就会无法建立数据库连接。\n\n设置依赖关系，需要使用```Wants```字段和```Requires```字段。\n\n> **Wants**字段：表示```sshd.service```与```sshd-keygen.service```之间存在\"弱依赖\"关系，即如果```sshd-keygen.service```启动失败或停止运行，不影响```sshd.service```继续执行。\n\n> **Requires**字段则表示\"强依赖\"关系，即如果该服务启动失败或异常退出，那么```sshd.service```也必须退出。\n\n## 五、Service] 区块：启动行为\n> **Service**区块定义如何启动当前服务。\n\n#### 启动命令\n许多软件都有自己的环境参数文件，该文件可以用```EnvironmentFile```字段读取。\n\n> **EnvironmentFile**字段：指定当前服务的环境参数文件。该文件内部的key=value键值对，可以用key的形式，在当前配置文件中获取。\n\n上面的例子中，**sshd** 的环境参数文件是```/etc/sysconfig/sshd```。\n\n配置文件里面最重要的字段是**ExecStart**。\n\n> **ExecStart**字段：定义启动进程时执行的命令。\n\n上面的例子中，启动```sshd```，执行的命令是```/usr/sbin/sshd -D $OPTIONS```，其中的变量```$OPTIONS```就来自```EnvironmentFile```字段指定的环境参数文件。\n\n与之作用相似的，还有如下这些字段。\n```shell\nExecReload字段：重启服务时执行的命令\nExecStop字段：停止服务时执行的命令\nExecStartPre字段：启动服务之前执行的命令\nExecStartPost字段：启动服务之后执行的命令\nExecStopPost字段：停止服务之后执行的命令\n```\n\n#### 启动类型\n**Type**字段定义启动类型。它可以设置的值如下。\n```shell\nsimple（默认值）：ExecStart字段启动的进程为主进程\nforking：ExecStart字段将以fork()方式启动，此时父进程将会退出，子进程将成为主进程\noneshot：类似于simple，但只执行一次，Systemd 会等它执行完，才启动其他服务\ndbus：类似于simple，但会等待 D-Bus 信号后启动\nnotify：类似于simple，启动结束后会发出通知信号，然后 Systemd 再启动其他服务\nidle：类似于simple，但是要等到其他任务都执行完，才会启动该服务。一种使用场合是为让该服务的输出，不与其他服务的输出相混合\n```\n下面是一个**oneshot**的例子，笔记本电脑启动时，要把触摸板关掉，配置文件可以这样写。\n```shell\n[Unit]\nDescription=Switch-off Touchpad\n\n[Service]\nType=oneshot\nExecStart=/usr/bin/touchpad-off\n\n[Install]\nWantedBy=multi-user.target\n```\n上面的配置文件，启动类型设为**oneshot**，就表明这个服务只要运行一次就够了，不需要长期运行。\n\n如果关闭以后，将来某个时候还想打开，配置文件修改如下。\n```shell\n[Unit]\nDescription=Switch-off Touchpad\n\n[Service]\nType=oneshot\nExecStart=/usr/bin/touchpad-off start\nExecStop=/usr/bin/touchpad-off stop\nRemainAfterExit=yes\n\n[Install]\nWantedBy=multi-user.target\n```\n上面配置文件中，**RemainAfterExit**字段设为**yes**，表示进程退出以后，服务仍然保持执行。这样的话，一旦使用**systemctl stop**命令停止服务，**ExecStop**指定的命令就会执行，从而重新开启触摸板。\n\n#### 重启行为\n\n"},{"title":"hexo的常用命令","url":"/2023/10/28/hexo的常用命令/","content":"## 安装、升级\n```\nnpm install hexo -g #安装  \nnpm update hexo -g #升级  \n```\n## 基本命令\n```hexo init```  \n初始化站点，生成一个简单网站所需的各种文件。\n\n```hexo clean == hexo c```   \n清除缓存 网页正常情况下可以忽略此条命令\n\n```hexo generate == hexo g```  \n生效新增、修改、更新的文件\n\nHexo 能够监视文件变动并立即重新生成静态文件，在生成时会比对文件的 SHA1 checksum，只有变动的文件才会写入。```hexo generate --watch```\n\n```hexo server == hexo s```  \n启动本地网站，可在本地观察网站效果，同时也可以输入```http://localhost:4000/admin```管理文章\n\n```hexo s --draft```  \n这个发布时可以预览草稿\n\n```hexo s --debug```  \n以调试模式启动本地网站，在此模式下，对文件的更改无需停止网站只需刷新即可看到效果，调试非常方便\n\n```hexo clean && hexo s```  \n一次执行两个命令\n\n```hexo deploy == hexo d```  \nhexo的一键部署功能，执行此命令即可将网站发布到配置中的仓库地址，执行此命令前需要配置站点配置文件_config.yml\n\n一键本地启动：```hexo clean && hexo g && hexo s```\n\n一键部署：```hexo clean && hexo g && hexo d```\n\n您可执行下列的其中一个命令，让 Hexo 在生成完毕后自动部署网站，两个命令的作用是相同的。\n```\nhexo generate --deploy\nhexo deploy --generate  或 hexo g -d or hexo d -g\n```\n## 创建和发布文章\n```hexo new [layout] <title>```  \n新建一篇新文章，会自动按照模板里面的格式创建文章\n\n里面的布局（layout），默认为 post，布局共有三种：\n```\npost\tsource/_posts\npage\tsource\ndraft\tsource/_drafts\n```\n#### 发布草稿命令：\n```\nhexo publish 文章文件名\n或者是手动将_drafts目录下的草稿移动到_posts目录下即可发布草稿为正式文章。\n```\n## PicGO图床快捷键\n快捷键为：```ctrl+shift+p```\n## Hexo博客头部配置\n\n#### （1）文章置顶\n在文章的 Front-Matter 中，使用 ```top: true``` 来实现置顶。\n\n#### （2）自定义样式\n如果你想修改主题的样式，推荐将样式代码添加到 ```source/css/_custom``` 目录下的 ```index.styl``` 文件中。这样，当主题更新时，不会覆盖你已经修改了的样式代码。\n> 当然，你也可以进行模块化分类：在该目录下新建样式文件，然后通过 @import xxx 语句在同目录下的 index.styl 文件中引入你新建的样式文件。\n\n#### （3）文章左侧目录\n启用文章目录后，默认对所有文章页面生效。你可以在 Front-Matter 中，设置 ```toc: false``` 来指定某篇文章不启用该功能。\n\n#### （4）文章业内目录\n```@[TOC]( )```这个写到文章页面内任何一个地方即可\n\n#### 更多详细设置，请参考 [hexo-theme-stun](https://theme-stun.github.io/docs/zh-CN/)\n"},{"title":"codeforces882D","url":"/2023/09/07/codeforces882D/","content":"[codeforces1870C](https://codeforces.com/problemset/problem/882/D)\n连续 $n$ 个数字里边必有能整除 $n$ 的数字 , 所以只需从 $1$ 开始枚举 .\n\n```C++\n#include<iostream>\nusing namespace std;\nint main()\n{\n    int t;\n    cin>>t;\n    while(t--){\n        long long int n;\n        cin>>n;\n        int ans=0;\n        for(int i=1;i<=n;i++){\n            if(n%i==0) ans++;\n            else break;\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n```\n","tags":["codeforces"],"categories":["codeforces"]},{"title":"codeforces1870C","url":"/2023/09/07/codeforces1870C/","content":"[codeforces1870C][def]\n\n## 题意\n给你两个整数 $n$ 和 $k$。同时给你一个大小为 $n$的整数数组 $a_1, a_2, \\ldots, a_n$。已知对于所有 $1 \\leq i \\leq n$， $1 \\leq a_i \\leq k$.\n\n定义大小为 $n \\times n$的二维数组 $b$如下：$b_{i, j} = \\min(a_i, a_j)$.将数组$b$表示为一个正方形，其中左上角的单元格为$b_{1, 1}$，行的编号从上到下从$1$到$n$，列的编号从左到右从$1$到$n$。让一个单元格的颜色就是写在其中的数字(坐标为$(i, j)$的单元格的颜色是$b_{i, j}$) .\n\n对于从 $1$ 到 $k$ 的每种颜色，找出数组 $b$ 中包含该颜色所有单元格的最小矩形。输出该矩形的宽和高之和 .\n\n## 方法 一\n$b_{i,j} =\\min(a_i, a_j)$ $->$求$a[i]$最左边和最右边大于等于$a[i]$的数的下标, 即$ans[i]=(ri[i]-li[i]+1)*2$ 。\n\n```c++\n#include<iostream>\n#include<vector>\nusing namespace std;\nconst int N=100005;\nint le[N],ri[N];\nint main()\n{\n    int t;\n    cin>>t;\n    while(t--){\n        int n,k;\n        cin>>n>>k;\n        vector<int>a(n+1);\n        vector<bool>st(k+1);\n        for(int i=1;i<=n;i++) cin>>a[i],st[a[i]]=true;\n        int now=0;\n        for(int i=1;i<=n;i++){\n            while(now<a[i]) le[++now]=i; //求最左边大于等于a[i]的数的下标\n        }\n        now=0;\n        for(int i=n;i>=1;i--){\n            while(now<a[i]) ri[++now]=i; //求最右边大于等于a[i]的数的下标\n        }\n        for(int i=1;i<=k;i++){\n            cout<<(st[i]?(ri[i]-le[i]+1)*2:0)<<\" \";\n        }\n        cout<<endl;\n    }\n    return 0;\n}\n\n```\n\n[def]: https://codeforces.com/problemset/problem/1870/C","tags":["codeforces"],"categories":["codeforces"]},{"title":"Win11 Activation","url":"/2023/09/07/Win11Activation/","content":"## win11专业版激活\n\n```shell\n用管理员在cmd中输入下列命令:\n1.slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX\n2.slmgr /skms kms.03k.org\n3.slmgr /ato\n```\n","categories":["杂项"]}]